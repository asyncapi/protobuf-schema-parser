asyncapi: 2.0.0
info:
  title: Example using ProtoBuff and https://github.com/bufbuild/protovalidate/blob/main/proto/protovalidate/buf/validate/validate.proto
  version: '1.0.0'
channels:
  mychannel:
    publish:
      message:
        $ref: '#/components/messages/testMessage'

components:
  messages:
    testMessage:
      schemaFormat: 'application/vnd.google.protobuf;version=3'
      payload: |
        syntax = "proto2";
        
        // based on: https://github.com/bufbuild/protovalidate/blob/main/proto/protovalidate/buf/validate/validate.proto
        // Currently not used but keep for future feature implementation.

        package buf.validate;

        // FloatRules describes the constraints applied to `float` values. These
        // rules may also be applied to the `google.protobuf.FloatValue` Well-Known-Type.
        message FloatRules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyFloat {
          //   // value must equal 42.0
          //   float value = 1 [(buf.validate.field).float.const = 42.0];
          // }
          // ```
          optional float const = 1 [(predefined).cel = {
            id: "float.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];

          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field <
            // value). If the field value is equal to or greater than the specified value,
            // an error message is generated.
            //
            // ```proto
            // message MyFloat {
            //   // value must be less than 10.0
            //   float value = 1 [(buf.validate.field).float.lt = 10.0];
            // }
            // ```
            float lt = 2 [(predefined).cel = {
              id: "float.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this >= rules.lt)"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MyFloat {
            //   // value must be less than or equal to 10.0
            //   float value = 1 [(buf.validate.field).float.lte = 10.0];
            // }
            // ```
            float lte = 3 [(predefined).cel = {
              id: "float.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this > rules.lte)"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }

          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyFloat {
            //   // value must be greater than 5.0 [float.gt]
            //   float value = 1 [(buf.validate.field).float.gt = 5.0];
            //
            //   // value must be greater than 5 and less than 10.0 [float.gt_lt]
            //   float other_value = 2 [(buf.validate.field).float = { gt: 5.0, lt: 10.0 }];
            //
            //   // value must be greater than 10 or less than 5.0 [float.gt_lt_exclusive]
            //   float another_value = 3 [(buf.validate.field).float = { gt: 10.0, lt: 5.0 }];
            // }
            // ```
            float gt = 4 [
              (predefined).cel = {
                id: "float.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this <= rules.gt)"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "float.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this.isNan() || this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "float.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (this.isNan() || (rules.lt <= this && this <= rules.gt))"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "float.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this.isNan() || this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "float.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (this.isNan() || (rules.lte < this && this <= rules.gt))"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt`
            // or `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyFloat {
            //   // value must be greater than or equal to 5.0 [float.gte]
            //   float value = 1 [(buf.validate.field).float.gte = 5.0];
            //
            //   // value must be greater than or equal to 5.0 and less than 10.0 [float.gte_lt]
            //   float other_value = 2 [(buf.validate.field).float = { gte: 5.0, lt: 10.0 }];
            //
            //   // value must be greater than or equal to 10.0 or less than 5.0 [float.gte_lt_exclusive]
            //   float another_value = 3 [(buf.validate.field).float = { gte: 10.0, lt: 5.0 }];
            // }
            // ```
            float gte = 5 [
              (predefined).cel = {
                id: "float.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this < rules.gte)"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "float.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this.isNan() || this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "float.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (this.isNan() || (rules.lt <= this && this < rules.gte))"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "float.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this.isNan() || this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "float.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (this.isNan() || (rules.lte < this && this < rules.gte))"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }

          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message
          // is generated.
          //
          // ```proto
          // message MyFloat {
          //   // value must be in list [1.0, 2.0, 3.0]
          //   repeated float value = 1 (buf.validate.field).float = { in: [1.0, 2.0, 3.0] };
          // }
          // ```
          repeated float in = 6 [(predefined).cel = {
            id: "float.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MyFloat {
          //   // value must not be in list [1.0, 2.0, 3.0]
          //   repeated float value = 1 (buf.validate.field).float = { not_in: [1.0, 2.0, 3.0] };
          // }
          // ```
          repeated float not_in = 7 [(predefined).cel = {
            id: "float.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `finite` requires the field value to be finite. If the field value is
          // infinite or NaN, an error message is generated.
          optional bool finite = 8 [(predefined).cel = {
            id: "float.finite"
            expression: "rules.finite ? (this.isNan() || this.isInf() ? 'value must be finite' : '') : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyFloat {
          //   float value = 1 [
          //     (buf.validate.field).float.example = 1.0,
          //     (buf.validate.field).float.example = "Infinity"
          //   ];
          // }
          // ```
          repeated float example = 9 [(predefined).cel = {
            id: "float.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // DoubleRules describes the constraints applied to `double` values. These
        // rules may also be applied to the `google.protobuf.DoubleValue` Well-Known-Type.
        message DoubleRules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyDouble {
          //   // value must equal 42.0
          //   double value = 1 [(buf.validate.field).double.const = 42.0];
          // }
          // ```
          optional double const = 1 [(predefined).cel = {
            id: "double.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field <
            // value). If the field value is equal to or greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MyDouble {
            //   // value must be less than 10.0
            //   double value = 1 [(buf.validate.field).double.lt = 10.0];
            // }
            // ```
            double lt = 2 [(predefined).cel = {
              id: "double.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this >= rules.lt)"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified value
            // (field <= value). If the field value is greater than the specified value,
            // an error message is generated.
            //
            // ```proto
            // message MyDouble {
            //   // value must be less than or equal to 10.0
            //   double value = 1 [(buf.validate.field).double.lte = 10.0];
            // }
            // ```
            double lte = 3 [(predefined).cel = {
              id: "double.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this > rules.lte)"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or `lte`,
            // the range is reversed, and the field value must be outside the specified
            // range. If the field value doesn't meet the required conditions, an error
            // message is generated.
            //
            // ```proto
            // message MyDouble {
            //   // value must be greater than 5.0 [double.gt]
            //   double value = 1 [(buf.validate.field).double.gt = 5.0];
            //
            //   // value must be greater than 5 and less than 10.0 [double.gt_lt]
            //   double other_value = 2 [(buf.validate.field).double = { gt: 5.0, lt: 10.0 }];
            //
            //   // value must be greater than 10 or less than 5.0 [double.gt_lt_exclusive]
            //   double another_value = 3 [(buf.validate.field).double = { gt: 10.0, lt: 5.0 }];
            // }
            // ```
            double gt = 4 [
              (predefined).cel = {
                id: "double.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this <= rules.gt)"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "double.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this.isNan() || this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "double.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (this.isNan() || (rules.lt <= this && this <= rules.gt))"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "double.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this.isNan() || this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "double.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (this.isNan() || (rules.lte < this && this <= rules.gt))"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyDouble {
            //   // value must be greater than or equal to 5.0 [double.gte]
            //   double value = 1 [(buf.validate.field).double.gte = 5.0];
            //
            //   // value must be greater than or equal to 5.0 and less than 10.0 [double.gte_lt]
            //   double other_value = 2 [(buf.validate.field).double = { gte: 5.0, lt: 10.0 }];
            //
            //   // value must be greater than or equal to 10.0 or less than 5.0 [double.gte_lt_exclusive]
            //   double another_value = 3 [(buf.validate.field).double = { gte: 10.0, lt: 5.0 }];
            // }
            // ```
            double gte = 5 [
              (predefined).cel = {
                id: "double.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this < rules.gte)"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "double.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this.isNan() || this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "double.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (this.isNan() || (rules.lt <= this && this < rules.gte))"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "double.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this.isNan() || this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "double.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (this.isNan() || (rules.lte < this && this < rules.gte))"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }
          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message is
          // generated.
          //
          // ```proto
          // message MyDouble {
          //   // value must be in list [1.0, 2.0, 3.0]
          //   repeated double value = 1 (buf.validate.field).double = { in: [1.0, 2.0, 3.0] };
          // }
          // ```
          repeated double in = 6 [(predefined).cel = {
            id: "double.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MyDouble {
          //   // value must not be in list [1.0, 2.0, 3.0]
          //   repeated double value = 1 (buf.validate.field).double = { not_in: [1.0, 2.0, 3.0] };
          // }
          // ```
          repeated double not_in = 7 [(predefined).cel = {
            id: "double.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `finite` requires the field value to be finite. If the field value is
          // infinite or NaN, an error message is generated.
          optional bool finite = 8 [(predefined).cel = {
            id: "double.finite"
            expression: "rules.finite ? (this.isNan() || this.isInf() ? 'value must be finite' : '') : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyDouble {
          //   double value = 1 [
          //     (buf.validate.field).double.example = 1.0,
          //     (buf.validate.field).double.example = "Infinity"
          //   ];
          // }
          // ```
          repeated double example = 9 [(predefined).cel = {
            id: "double.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // Int32Rules describes the constraints applied to `int32` values. These
        // rules may also be applied to the `google.protobuf.Int32Value` Well-Known-Type.
        message Int32Rules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyInt32 {
          //   // value must equal 42
          //   int32 value = 1 [(buf.validate.field).int32.const = 42];
          // }
          // ```
          optional int32 const = 1 [(predefined).cel = {
            id: "int32.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field
            // < value). If the field value is equal to or greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MyInt32 {
            //   // value must be less than 10
            //   int32 value = 1 [(buf.validate.field).int32.lt = 10];
            // }
            // ```
            int32 lt = 2 [(predefined).cel = {
              id: "int32.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MyInt32 {
            //   // value must be less than or equal to 10
            //   int32 value = 1 [(buf.validate.field).int32.lte = 10];
            // }
            // ```
            int32 lte = 3 [(predefined).cel = {
              id: "int32.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyInt32 {
            //   // value must be greater than 5 [int32.gt]
            //   int32 value = 1 [(buf.validate.field).int32.gt = 5];
            //
            //   // value must be greater than 5 and less than 10 [int32.gt_lt]
            //   int32 other_value = 2 [(buf.validate.field).int32 = { gt: 5, lt: 10 }];
            //
            //   // value must be greater than 10 or less than 5 [int32.gt_lt_exclusive]
            //   int32 another_value = 3 [(buf.validate.field).int32 = { gt: 10, lt: 5 }];
            // }
            // ```
            int32 gt = 4 [
              (predefined).cel = {
                id: "int32.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "int32.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "int32.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "int32.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "int32.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified value
            // (exclusive). If the value of `gte` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyInt32 {
            //   // value must be greater than or equal to 5 [int32.gte]
            //   int32 value = 1 [(buf.validate.field).int32.gte = 5];
            //
            //   // value must be greater than or equal to 5 and less than 10 [int32.gte_lt]
            //   int32 other_value = 2 [(buf.validate.field).int32 = { gte: 5, lt: 10 }];
            //
            //   // value must be greater than or equal to 10 or less than 5 [int32.gte_lt_exclusive]
            //   int32 another_value = 3 [(buf.validate.field).int32 = { gte: 10, lt: 5 }];
            // }
            // ```
            int32 gte = 5 [
              (predefined).cel = {
                id: "int32.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "int32.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "int32.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "int32.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "int32.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }

          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message is
          // generated.
          //
          // ```proto
          // message MyInt32 {
          //   // value must be in list [1, 2, 3]
          //   repeated int32 value = 1 (buf.validate.field).int32 = { in: [1, 2, 3] };
          // }
          // ```
          repeated int32 in = 6 [(predefined).cel = {
            id: "int32.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error message
          // is generated.
          //
          // ```proto
          // message MyInt32 {
          //   // value must not be in list [1, 2, 3]
          //   repeated int32 value = 1 (buf.validate.field).int32 = { not_in: [1, 2, 3] };
          // }
          // ```
          repeated int32 not_in = 7 [(predefined).cel = {
            id: "int32.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyInt32 {
          //   int32 value = 1 [
          //     (buf.validate.field).int32.example = 1,
          //     (buf.validate.field).int32.example = -10
          //   ];
          // }
          // ```
          repeated int32 example = 8 [(predefined).cel = {
            id: "int32.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // Int64Rules describes the constraints applied to `int64` values. These
        // rules may also be applied to the `google.protobuf.Int64Value` Well-Known-Type.
        message Int64Rules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyInt64 {
          //   // value must equal 42
          //   int64 value = 1 [(buf.validate.field).int64.const = 42];
          // }
          // ```
          optional int64 const = 1 [(predefined).cel = {
            id: "int64.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field <
            // value). If the field value is equal to or greater than the specified value,
            // an error message is generated.
            //
            // ```proto
            // message MyInt64 {
            //   // value must be less than 10
            //   int64 value = 1 [(buf.validate.field).int64.lt = 10];
            // }
            // ```
            int64 lt = 2 [(predefined).cel = {
              id: "int64.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MyInt64 {
            //   // value must be less than or equal to 10
            //   int64 value = 1 [(buf.validate.field).int64.lte = 10];
            // }
            // ```
            int64 lte = 3 [(predefined).cel = {
              id: "int64.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyInt64 {
            //   // value must be greater than 5 [int64.gt]
            //   int64 value = 1 [(buf.validate.field).int64.gt = 5];
            //
            //   // value must be greater than 5 and less than 10 [int64.gt_lt]
            //   int64 other_value = 2 [(buf.validate.field).int64 = { gt: 5, lt: 10 }];
            //
            //   // value must be greater than 10 or less than 5 [int64.gt_lt_exclusive]
            //   int64 another_value = 3 [(buf.validate.field).int64 = { gt: 10, lt: 5 }];
            // }
            // ```
            int64 gt = 4 [
              (predefined).cel = {
                id: "int64.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "int64.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "int64.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "int64.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "int64.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt`
            // or `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyInt64 {
            //   // value must be greater than or equal to 5 [int64.gte]
            //   int64 value = 1 [(buf.validate.field).int64.gte = 5];
            //
            //   // value must be greater than or equal to 5 and less than 10 [int64.gte_lt]
            //   int64 other_value = 2 [(buf.validate.field).int64 = { gte: 5, lt: 10 }];
            //
            //   // value must be greater than or equal to 10 or less than 5 [int64.gte_lt_exclusive]
            //   int64 another_value = 3 [(buf.validate.field).int64 = { gte: 10, lt: 5 }];
            // }
            // ```
            int64 gte = 5 [
              (predefined).cel = {
                id: "int64.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "int64.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "int64.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "int64.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "int64.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }

          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message is
          // generated.
          //
          // ```proto
          // message MyInt64 {
          //   // value must be in list [1, 2, 3]
          //   repeated int64 value = 1 (buf.validate.field).int64 = { in: [1, 2, 3] };
          // }
          // ```
          repeated int64 in = 6 [(predefined).cel = {
            id: "int64.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MyInt64 {
          //   // value must not be in list [1, 2, 3]
          //   repeated int64 value = 1 (buf.validate.field).int64 = { not_in: [1, 2, 3] };
          // }
          // ```
          repeated int64 not_in = 7 [(predefined).cel = {
            id: "int64.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyInt64 {
          //   int64 value = 1 [
          //     (buf.validate.field).int64.example = 1,
          //     (buf.validate.field).int64.example = -10
          //   ];
          // }
          // ```
          repeated int64 example = 9 [(predefined).cel = {
            id: "int64.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // UInt32Rules describes the constraints applied to `uint32` values. These
        // rules may also be applied to the `google.protobuf.UInt32Value` Well-Known-Type.
        message UInt32Rules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyUInt32 {
          //   // value must equal 42
          //   uint32 value = 1 [(buf.validate.field).uint32.const = 42];
          // }
          // ```
          optional uint32 const = 1 [(predefined).cel = {
            id: "uint32.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field <
            // value). If the field value is equal to or greater than the specified value,
            // an error message is generated.
            //
            // ```proto
            // message MyUInt32 {
            //   // value must be less than 10
            //   uint32 value = 1 [(buf.validate.field).uint32.lt = 10];
            // }
            // ```
            uint32 lt = 2 [(predefined).cel = {
              id: "uint32.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MyUInt32 {
            //   // value must be less than or equal to 10
            //   uint32 value = 1 [(buf.validate.field).uint32.lte = 10];
            // }
            // ```
            uint32 lte = 3 [(predefined).cel = {
              id: "uint32.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyUInt32 {
            //   // value must be greater than 5 [uint32.gt]
            //   uint32 value = 1 [(buf.validate.field).uint32.gt = 5];
            //
            //   // value must be greater than 5 and less than 10 [uint32.gt_lt]
            //   uint32 other_value = 2 [(buf.validate.field).uint32 = { gt: 5, lt: 10 }];
            //
            //   // value must be greater than 10 or less than 5 [uint32.gt_lt_exclusive]
            //   uint32 another_value = 3 [(buf.validate.field).uint32 = { gt: 10, lt: 5 }];
            // }
            // ```
            uint32 gt = 4 [
              (predefined).cel = {
                id: "uint32.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "uint32.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "uint32.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "uint32.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "uint32.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt`
            // or `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyUInt32 {
            //   // value must be greater than or equal to 5 [uint32.gte]
            //   uint32 value = 1 [(buf.validate.field).uint32.gte = 5];
            //
            //   // value must be greater than or equal to 5 and less than 10 [uint32.gte_lt]
            //   uint32 other_value = 2 [(buf.validate.field).uint32 = { gte: 5, lt: 10 }];
            //
            //   // value must be greater than or equal to 10 or less than 5 [uint32.gte_lt_exclusive]
            //   uint32 another_value = 3 [(buf.validate.field).uint32 = { gte: 10, lt: 5 }];
            // }
            // ```
            uint32 gte = 5 [
              (predefined).cel = {
                id: "uint32.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "uint32.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "uint32.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "uint32.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "uint32.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }

          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message is
          // generated.
          //
          // ```proto
          // message MyUInt32 {
          //   // value must be in list [1, 2, 3]
          //   repeated uint32 value = 1 (buf.validate.field).uint32 = { in: [1, 2, 3] };
          // }
          // ```
          repeated uint32 in = 6 [(predefined).cel = {
            id: "uint32.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MyUInt32 {
          //   // value must not be in list [1, 2, 3]
          //   repeated uint32 value = 1 (buf.validate.field).uint32 = { not_in: [1, 2, 3] };
          // }
          // ```
          repeated uint32 not_in = 7 [(predefined).cel = {
            id: "uint32.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyUInt32 {
          //   uint32 value = 1 [
          //     (buf.validate.field).uint32.example = 1,
          //     (buf.validate.field).uint32.example = 10
          //   ];
          // }
          // ```
          repeated uint32 example = 8 [(predefined).cel = {
            id: "uint32.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // UInt64Rules describes the constraints applied to `uint64` values. These
        // rules may also be applied to the `google.protobuf.UInt64Value` Well-Known-Type.
        message UInt64Rules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyUInt64 {
          //   // value must equal 42
          //   uint64 value = 1 [(buf.validate.field).uint64.const = 42];
          // }
          // ```
          optional uint64 const = 1 [(predefined).cel = {
            id: "uint64.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field <
            // value). If the field value is equal to or greater than the specified value,
            // an error message is generated.
            //
            // ```proto
            // message MyUInt64 {
            //   // value must be less than 10
            //   uint64 value = 1 [(buf.validate.field).uint64.lt = 10];
            // }
            // ```
            uint64 lt = 2 [(predefined).cel = {
              id: "uint64.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MyUInt64 {
            //   // value must be less than or equal to 10
            //   uint64 value = 1 [(buf.validate.field).uint64.lte = 10];
            // }
            // ```
            uint64 lte = 3 [(predefined).cel = {
              id: "uint64.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyUInt64 {
            //   // value must be greater than 5 [uint64.gt]
            //   uint64 value = 1 [(buf.validate.field).uint64.gt = 5];
            //
            //   // value must be greater than 5 and less than 10 [uint64.gt_lt]
            //   uint64 other_value = 2 [(buf.validate.field).uint64 = { gt: 5, lt: 10 }];
            //
            //   // value must be greater than 10 or less than 5 [uint64.gt_lt_exclusive]
            //   uint64 another_value = 3 [(buf.validate.field).uint64 = { gt: 10, lt: 5 }];
            // }
            // ```
            uint64 gt = 4 [
              (predefined).cel = {
                id: "uint64.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "uint64.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "uint64.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "uint64.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "uint64.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt`
            // or `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyUInt64 {
            //   // value must be greater than or equal to 5 [uint64.gte]
            //   uint64 value = 1 [(buf.validate.field).uint64.gte = 5];
            //
            //   // value must be greater than or equal to 5 and less than 10 [uint64.gte_lt]
            //   uint64 other_value = 2 [(buf.validate.field).uint64 = { gte: 5, lt: 10 }];
            //
            //   // value must be greater than or equal to 10 or less than 5 [uint64.gte_lt_exclusive]
            //   uint64 another_value = 3 [(buf.validate.field).uint64 = { gte: 10, lt: 5 }];
            // }
            // ```
            uint64 gte = 5 [
              (predefined).cel = {
                id: "uint64.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "uint64.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "uint64.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "uint64.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "uint64.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }
          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message is
          // generated.
          //
          // ```proto
          // message MyUInt64 {
          //   // value must be in list [1, 2, 3]
          //   repeated uint64 value = 1 (buf.validate.field).uint64 = { in: [1, 2, 3] };
          // }
          // ```
          repeated uint64 in = 6 [(predefined).cel = {
            id: "uint64.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MyUInt64 {
          //   // value must not be in list [1, 2, 3]
          //   repeated uint64 value = 1 (buf.validate.field).uint64 = { not_in: [1, 2, 3] };
          // }
          // ```
          repeated uint64 not_in = 7 [(predefined).cel = {
            id: "uint64.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyUInt64 {
          //   uint64 value = 1 [
          //     (buf.validate.field).uint64.example = 1,
          //     (buf.validate.field).uint64.example = -10
          //   ];
          // }
          // ```
          repeated uint64 example = 8 [(predefined).cel = {
            id: "uint64.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // SInt32Rules describes the constraints applied to `sint32` values.
        message SInt32Rules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MySInt32 {
          //   // value must equal 42
          //   sint32 value = 1 [(buf.validate.field).sint32.const = 42];
          // }
          // ```
          optional sint32 const = 1 [(predefined).cel = {
            id: "sint32.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field
            // < value). If the field value is equal to or greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MySInt32 {
            //   // value must be less than 10
            //   sint32 value = 1 [(buf.validate.field).sint32.lt = 10];
            // }
            // ```
            sint32 lt = 2 [(predefined).cel = {
              id: "sint32.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MySInt32 {
            //   // value must be less than or equal to 10
            //   sint32 value = 1 [(buf.validate.field).sint32.lte = 10];
            // }
            // ```
            sint32 lte = 3 [(predefined).cel = {
              id: "sint32.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MySInt32 {
            //   // value must be greater than 5 [sint32.gt]
            //   sint32 value = 1 [(buf.validate.field).sint32.gt = 5];
            //
            //   // value must be greater than 5 and less than 10 [sint32.gt_lt]
            //   sint32 other_value = 2 [(buf.validate.field).sint32 = { gt: 5, lt: 10 }];
            //
            //   // value must be greater than 10 or less than 5 [sint32.gt_lt_exclusive]
            //   sint32 another_value = 3 [(buf.validate.field).sint32 = { gt: 10, lt: 5 }];
            // }
            // ```
            sint32 gt = 4 [
              (predefined).cel = {
                id: "sint32.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "sint32.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sint32.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sint32.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "sint32.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt`
            // or `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MySInt32 {
            //  // value must be greater than or equal to 5 [sint32.gte]
            //  sint32 value = 1 [(buf.validate.field).sint32.gte = 5];
            //
            //  // value must be greater than or equal to 5 and less than 10 [sint32.gte_lt]
            //  sint32 other_value = 2 [(buf.validate.field).sint32 = { gte: 5, lt: 10 }];
            //
            //  // value must be greater than or equal to 10 or less than 5 [sint32.gte_lt_exclusive]
            //  sint32 another_value = 3 [(buf.validate.field).sint32 = { gte: 10, lt: 5 }];
            // }
            // ```
            sint32 gte = 5 [
              (predefined).cel = {
                id: "sint32.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "sint32.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sint32.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sint32.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "sint32.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }

          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message is
          // generated.
          //
          // ```proto
          // message MySInt32 {
          //   // value must be in list [1, 2, 3]
          //   repeated sint32 value = 1 (buf.validate.field).sint32 = { in: [1, 2, 3] };
          // }
          // ```
          repeated sint32 in = 6 [(predefined).cel = {
            id: "sint32.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MySInt32 {
          //   // value must not be in list [1, 2, 3]
          //   repeated sint32 value = 1 (buf.validate.field).sint32 = { not_in: [1, 2, 3] };
          // }
          // ```
          repeated sint32 not_in = 7 [(predefined).cel = {
            id: "sint32.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MySInt32 {
          //   sint32 value = 1 [
          //     (buf.validate.field).sint32.example = 1,
          //     (buf.validate.field).sint32.example = -10
          //   ];
          // }
          // ```
          repeated sint32 example = 8 [(predefined).cel = {
            id: "sint32.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // SInt64Rules describes the constraints applied to `sint64` values.
        message SInt64Rules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MySInt64 {
          //   // value must equal 42
          //   sint64 value = 1 [(buf.validate.field).sint64.const = 42];
          // }
          // ```
          optional sint64 const = 1 [(predefined).cel = {
            id: "sint64.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field
            // < value). If the field value is equal to or greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MySInt64 {
            //   // value must be less than 10
            //   sint64 value = 1 [(buf.validate.field).sint64.lt = 10];
            // }
            // ```
            sint64 lt = 2 [(predefined).cel = {
              id: "sint64.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MySInt64 {
            //   // value must be less than or equal to 10
            //   sint64 value = 1 [(buf.validate.field).sint64.lte = 10];
            // }
            // ```
            sint64 lte = 3 [(predefined).cel = {
              id: "sint64.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MySInt64 {
            //   // value must be greater than 5 [sint64.gt]
            //   sint64 value = 1 [(buf.validate.field).sint64.gt = 5];
            //
            //   // value must be greater than 5 and less than 10 [sint64.gt_lt]
            //   sint64 other_value = 2 [(buf.validate.field).sint64 = { gt: 5, lt: 10 }];
            //
            //   // value must be greater than 10 or less than 5 [sint64.gt_lt_exclusive]
            //   sint64 another_value = 3 [(buf.validate.field).sint64 = { gt: 10, lt: 5 }];
            // }
            // ```
            sint64 gt = 4 [
              (predefined).cel = {
                id: "sint64.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "sint64.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sint64.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sint64.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "sint64.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt`
            // or `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MySInt64 {
            //   // value must be greater than or equal to 5 [sint64.gte]
            //   sint64 value = 1 [(buf.validate.field).sint64.gte = 5];
            //
            //   // value must be greater than or equal to 5 and less than 10 [sint64.gte_lt]
            //   sint64 other_value = 2 [(buf.validate.field).sint64 = { gte: 5, lt: 10 }];
            //
            //   // value must be greater than or equal to 10 or less than 5 [sint64.gte_lt_exclusive]
            //   sint64 another_value = 3 [(buf.validate.field).sint64 = { gte: 10, lt: 5 }];
            // }
            // ```
            sint64 gte = 5 [
              (predefined).cel = {
                id: "sint64.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "sint64.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sint64.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sint64.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "sint64.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }

          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message
          // is generated.
          //
          // ```proto
          // message MySInt64 {
          //   // value must be in list [1, 2, 3]
          //   repeated sint64 value = 1 (buf.validate.field).sint64 = { in: [1, 2, 3] };
          // }
          // ```
          repeated sint64 in = 6 [(predefined).cel = {
            id: "sint64.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MySInt64 {
          //   // value must not be in list [1, 2, 3]
          //   repeated sint64 value = 1 (buf.validate.field).sint64 = { not_in: [1, 2, 3] };
          // }
          // ```
          repeated sint64 not_in = 7 [(predefined).cel = {
            id: "sint64.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MySInt64 {
          //   sint64 value = 1 [
          //     (buf.validate.field).sint64.example = 1,
          //     (buf.validate.field).sint64.example = -10
          //   ];
          // }
          // ```
          repeated sint64 example = 8 [(predefined).cel = {
            id: "sint64.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // Fixed32Rules describes the constraints applied to `fixed32` values.
        message Fixed32Rules {
          // `const` requires the field value to exactly match the specified value.
          // If the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyFixed32 {
          //   // value must equal 42
          //   fixed32 value = 1 [(buf.validate.field).fixed32.const = 42];
          // }
          // ```
          optional fixed32 const = 1 [(predefined).cel = {
            id: "fixed32.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field <
            // value). If the field value is equal to or greater than the specified value,
            // an error message is generated.
            //
            // ```proto
            // message MyFixed32 {
            //   // value must be less than 10
            //   fixed32 value = 1 [(buf.validate.field).fixed32.lt = 10];
            // }
            // ```
            fixed32 lt = 2 [(predefined).cel = {
              id: "fixed32.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MyFixed32 {
            //   // value must be less than or equal to 10
            //   fixed32 value = 1 [(buf.validate.field).fixed32.lte = 10];
            // }
            // ```
            fixed32 lte = 3 [(predefined).cel = {
              id: "fixed32.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyFixed32 {
            //   // value must be greater than 5 [fixed32.gt]
            //   fixed32 value = 1 [(buf.validate.field).fixed32.gt = 5];
            //
            //   // value must be greater than 5 and less than 10 [fixed32.gt_lt]
            //   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gt: 5, lt: 10 }];
            //
            //   // value must be greater than 10 or less than 5 [fixed32.gt_lt_exclusive]
            //   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gt: 10, lt: 5 }];
            // }
            // ```
            fixed32 gt = 4 [
              (predefined).cel = {
                id: "fixed32.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "fixed32.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "fixed32.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "fixed32.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "fixed32.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt`
            // or `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyFixed32 {
            //   // value must be greater than or equal to 5 [fixed32.gte]
            //   fixed32 value = 1 [(buf.validate.field).fixed32.gte = 5];
            //
            //   // value must be greater than or equal to 5 and less than 10 [fixed32.gte_lt]
            //   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gte: 5, lt: 10 }];
            //
            //   // value must be greater than or equal to 10 or less than 5 [fixed32.gte_lt_exclusive]
            //   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gte: 10, lt: 5 }];
            // }
            // ```
            fixed32 gte = 5 [
              (predefined).cel = {
                id: "fixed32.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "fixed32.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "fixed32.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "fixed32.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "fixed32.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }

          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message
          // is generated.
          //
          // ```proto
          // message MyFixed32 {
          //   // value must be in list [1, 2, 3]
          //   repeated fixed32 value = 1 (buf.validate.field).fixed32 = { in: [1, 2, 3] };
          // }
          // ```
          repeated fixed32 in = 6 [(predefined).cel = {
            id: "fixed32.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MyFixed32 {
          //   // value must not be in list [1, 2, 3]
          //   repeated fixed32 value = 1 (buf.validate.field).fixed32 = { not_in: [1, 2, 3] };
          // }
          // ```
          repeated fixed32 not_in = 7 [(predefined).cel = {
            id: "fixed32.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyFixed32 {
          //   fixed32 value = 1 [
          //     (buf.validate.field).fixed32.example = 1,
          //     (buf.validate.field).fixed32.example = 2
          //   ];
          // }
          // ```
          repeated fixed32 example = 8 [(predefined).cel = {
            id: "fixed32.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // Fixed64Rules describes the constraints applied to `fixed64` values.
        message Fixed64Rules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyFixed64 {
          //   // value must equal 42
          //   fixed64 value = 1 [(buf.validate.field).fixed64.const = 42];
          // }
          // ```
          optional fixed64 const = 1 [(predefined).cel = {
            id: "fixed64.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field <
            // value). If the field value is equal to or greater than the specified value,
            // an error message is generated.
            //
            // ```proto
            // message MyFixed64 {
            //   // value must be less than 10
            //   fixed64 value = 1 [(buf.validate.field).fixed64.lt = 10];
            // }
            // ```
            fixed64 lt = 2 [(predefined).cel = {
              id: "fixed64.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MyFixed64 {
            //   // value must be less than or equal to 10
            //   fixed64 value = 1 [(buf.validate.field).fixed64.lte = 10];
            // }
            // ```
            fixed64 lte = 3 [(predefined).cel = {
              id: "fixed64.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyFixed64 {
            //   // value must be greater than 5 [fixed64.gt]
            //   fixed64 value = 1 [(buf.validate.field).fixed64.gt = 5];
            //
            //   // value must be greater than 5 and less than 10 [fixed64.gt_lt]
            //   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gt: 5, lt: 10 }];
            //
            //   // value must be greater than 10 or less than 5 [fixed64.gt_lt_exclusive]
            //   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gt: 10, lt: 5 }];
            // }
            // ```

            fixed64 gt = 4 [
              (predefined).cel = {
                id: "fixed64.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "fixed64.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "fixed64.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "fixed64.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "fixed64.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt`
            // or `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MyFixed64 {
            //   // value must be greater than or equal to 5 [fixed64.gte]
            //   fixed64 value = 1 [(buf.validate.field).fixed64.gte = 5];
            //
            //   // value must be greater than or equal to 5 and less than 10 [fixed64.gte_lt]
            //   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gte: 5, lt: 10 }];
            //
            //   // value must be greater than or equal to 10 or less than 5 [fixed64.gte_lt_exclusive]
            //   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gte: 10, lt: 5 }];
            // }
            // ```
            fixed64 gte = 5 [
              (predefined).cel = {
                id: "fixed64.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "fixed64.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "fixed64.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "fixed64.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "fixed64.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }

          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message is
          // generated.
          //
          // ```proto
          // message MyFixed64 {
          //   // value must be in list [1, 2, 3]
          //   repeated fixed64 value = 1 (buf.validate.field).fixed64 = { in: [1, 2, 3] };
          // }
          // ```
          repeated fixed64 in = 6 [(predefined).cel = {
            id: "fixed64.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MyFixed64 {
          //   // value must not be in list [1, 2, 3]
          //   repeated fixed64 value = 1 (buf.validate.field).fixed64 = { not_in: [1, 2, 3] };
          // }
          // ```
          repeated fixed64 not_in = 7 [(predefined).cel = {
            id: "fixed64.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyFixed64 {
          //   fixed64 value = 1 [
          //     (buf.validate.field).fixed64.example = 1,
          //     (buf.validate.field).fixed64.example = 2
          //   ];
          // }
          // ```
          repeated fixed64 example = 8 [(predefined).cel = {
            id: "fixed64.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // SFixed32Rules describes the constraints applied to `fixed32` values.
        message SFixed32Rules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MySFixed32 {
          //   // value must equal 42
          //   sfixed32 value = 1 [(buf.validate.field).sfixed32.const = 42];
          // }
          // ```
          optional sfixed32 const = 1 [(predefined).cel = {
            id: "sfixed32.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field <
            // value). If the field value is equal to or greater than the specified value,
            // an error message is generated.
            //
            // ```proto
            // message MySFixed32 {
            //   // value must be less than 10
            //   sfixed32 value = 1 [(buf.validate.field).sfixed32.lt = 10];
            // }
            // ```
            sfixed32 lt = 2 [(predefined).cel = {
              id: "sfixed32.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MySFixed32 {
            //   // value must be less than or equal to 10
            //   sfixed32 value = 1 [(buf.validate.field).sfixed32.lte = 10];
            // }
            // ```
            sfixed32 lte = 3 [(predefined).cel = {
              id: "sfixed32.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MySFixed32 {
            //   // value must be greater than 5 [sfixed32.gt]
            //   sfixed32 value = 1 [(buf.validate.field).sfixed32.gt = 5];
            //
            //   // value must be greater than 5 and less than 10 [sfixed32.gt_lt]
            //   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gt: 5, lt: 10 }];
            //
            //   // value must be greater than 10 or less than 5 [sfixed32.gt_lt_exclusive]
            //   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gt: 10, lt: 5 }];
            // }
            // ```
            sfixed32 gt = 4 [
              (predefined).cel = {
                id: "sfixed32.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "sfixed32.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sfixed32.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sfixed32.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "sfixed32.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt`
            // or `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MySFixed32 {
            //   // value must be greater than or equal to 5 [sfixed32.gte]
            //   sfixed32 value = 1 [(buf.validate.field).sfixed32.gte = 5];
            //
            //   // value must be greater than or equal to 5 and less than 10 [sfixed32.gte_lt]
            //   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gte: 5, lt: 10 }];
            //
            //   // value must be greater than or equal to 10 or less than 5 [sfixed32.gte_lt_exclusive]
            //   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gte: 10, lt: 5 }];
            // }
            // ```
            sfixed32 gte = 5 [
              (predefined).cel = {
                id: "sfixed32.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "sfixed32.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sfixed32.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sfixed32.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "sfixed32.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }

          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message is
          // generated.
          //
          // ```proto
          // message MySFixed32 {
          //   // value must be in list [1, 2, 3]
          //   repeated sfixed32 value = 1 (buf.validate.field).sfixed32 = { in: [1, 2, 3] };
          // }
          // ```
          repeated sfixed32 in = 6 [(predefined).cel = {
            id: "sfixed32.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MySFixed32 {
          //   // value must not be in list [1, 2, 3]
          //   repeated sfixed32 value = 1 (buf.validate.field).sfixed32 = { not_in: [1, 2, 3] };
          // }
          // ```
          repeated sfixed32 not_in = 7 [(predefined).cel = {
            id: "sfixed32.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MySFixed32 {
          //   sfixed32 value = 1 [
          //     (buf.validate.field).sfixed32.example = 1,
          //     (buf.validate.field).sfixed32.example = 2
          //   ];
          // }
          // ```
          repeated sfixed32 example = 8 [(predefined).cel = {
            id: "sfixed32.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // SFixed64Rules describes the constraints applied to `fixed64` values.
        message SFixed64Rules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MySFixed64 {
          //   // value must equal 42
          //   sfixed64 value = 1 [(buf.validate.field).sfixed64.const = 42];
          // }
          // ```
          optional sfixed64 const = 1 [(predefined).cel = {
            id: "sfixed64.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];
          oneof less_than {
            // `lt` requires the field value to be less than the specified value (field <
            // value). If the field value is equal to or greater than the specified value,
            // an error message is generated.
            //
            // ```proto
            // message MySFixed64 {
            //   // value must be less than 10
            //   sfixed64 value = 1 [(buf.validate.field).sfixed64.lt = 10];
            // }
            // ```
            sfixed64 lt = 2 [(predefined).cel = {
              id: "sfixed64.lt"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
                "? 'value must be less than %s'.format([rules.lt]) : ''"
            }];

            // `lte` requires the field value to be less than or equal to the specified
            // value (field <= value). If the field value is greater than the specified
            // value, an error message is generated.
            //
            // ```proto
            // message MySFixed64 {
            //   // value must be less than or equal to 10
            //   sfixed64 value = 1 [(buf.validate.field).sfixed64.lte = 10];
            // }
            // ```
            sfixed64 lte = 3 [(predefined).cel = {
              id: "sfixed64.lte"
              expression:
                "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
                "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
            }];
          }
        
          oneof greater_than {
            // `gt` requires the field value to be greater than the specified value
            // (exclusive). If the value of `gt` is larger than a specified `lt` or
            // `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MySFixed64 {
            //   // value must be greater than 5 [sfixed64.gt]
            //   sfixed64 value = 1 [(buf.validate.field).sfixed64.gt = 5];
            //
            //   // value must be greater than 5 and less than 10 [sfixed64.gt_lt]
            //   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gt: 5, lt: 10 }];
            //
            //   // value must be greater than 10 or less than 5 [sfixed64.gt_lt_exclusive]
            //   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gt: 10, lt: 5 }];
            // }
            // ```
            sfixed64 gt = 4 [
              (predefined).cel = {
                id: "sfixed64.gt"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
                  "? 'value must be greater than %s'.format([rules.gt]) : ''"
              },
              (predefined).cel = {
                id: "sfixed64.gt_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
                  "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sfixed64.gt_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sfixed64.gt_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
                  "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "sfixed64.gt_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
                  "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
              }
            ];

            // `gte` requires the field value to be greater than or equal to the specified
            // value (exclusive). If the value of `gte` is larger than a specified `lt`
            // or `lte`, the range is reversed, and the field value must be outside the
            // specified range. If the field value doesn't meet the required conditions,
            // an error message is generated.
            //
            // ```proto
            // message MySFixed64 {
            //   // value must be greater than or equal to 5 [sfixed64.gte]
            //   sfixed64 value = 1 [(buf.validate.field).sfixed64.gte = 5];
            //
            //   // value must be greater than or equal to 5 and less than 10 [sfixed64.gte_lt]
            //   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gte: 5, lt: 10 }];
            //
            //   // value must be greater than or equal to 10 or less than 5 [sfixed64.gte_lt_exclusive]
            //   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gte: 10, lt: 5 }];
            // }
            // ```
            sfixed64 gte = 5 [
              (predefined).cel = {
                id: "sfixed64.gte"
                expression:
                  "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
                  "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
              },
              (predefined).cel = {
                id: "sfixed64.gte_lt"
                expression:
                  "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sfixed64.gte_lt_exclusive"
                expression:
                  "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
              },
              (predefined).cel = {
                id: "sfixed64.gte_lte"
                expression:
                  "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
                  "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              },
              (predefined).cel = {
                id: "sfixed64.gte_lte_exclusive"
                expression:
                  "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
                  "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
              }
            ];
          }

          // `in` requires the field value to be equal to one of the specified values.
          // If the field value isn't one of the specified values, an error message is
          // generated.
          //
          // ```proto
          // message MySFixed64 {
          //   // value must be in list [1, 2, 3]
          //   repeated sfixed64 value = 1 (buf.validate.field).sfixed64 = { in: [1, 2, 3] };
          // }
          // ```
          repeated sfixed64 in = 6 [(predefined).cel = {
            id: "sfixed64.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to not be equal to any of the specified
          // values. If the field value is one of the specified values, an error
          // message is generated.
          //
          // ```proto
          // message MySFixed64 {
          //   // value must not be in list [1, 2, 3]
          //   repeated sfixed64 value = 1 (buf.validate.field).sfixed64 = { not_in: [1, 2, 3] };
          // }
          // ```
          repeated sfixed64 not_in = 7 [(predefined).cel = {
            id: "sfixed64.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MySFixed64 {
          //   sfixed64 value = 1 [
          //     (buf.validate.field).sfixed64.example = 1,
          //     (buf.validate.field).sfixed64.example = 2
          //   ];
          // }
          // ```
          repeated sfixed64 example = 8 [(predefined).cel = {
            id: "sfixed64.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // BoolRules describes the constraints applied to `bool` values. These rules
        // may also be applied to the `google.protobuf.BoolValue` Well-Known-Type.
        message BoolRules {
          // `const` requires the field value to exactly match the specified boolean value.
          // If the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyBool {
          //   // value must equal true
          //   bool value = 1 [(buf.validate.field).bool.const = true];
          // }
          // ```
          optional bool const = 1 [(predefined).cel = {
            id: "bool.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyBool {
          //   bool value = 1 [
          //     (buf.validate.field).bool.example = 1,
          //     (buf.validate.field).bool.example = 2
          //   ];
          // }
          // ```
          repeated bool example = 2 [(predefined).cel = {
            id: "bool.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // StringRules describes the constraints applied to `string` values These
        // rules may also be applied to the `google.protobuf.StringValue` Well-Known-Type.
        message StringRules {
          // `const` requires the field value to exactly match the specified value. If
          // the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyString {
          //   // value must equal `hello`
          //   string value = 1 [(buf.validate.field).string.const = "hello"];
          // }
          // ```
          optional string const = 1 [(predefined).cel = {
            id: "string.const"
            expression: "this != rules.const ? 'value must equal `%s`'.format([rules.const]) : ''"
          }];

          // `len` dictates that the field value must have the specified
          // number of characters (Unicode code points), which may differ from the number
          // of bytes in the string. If the field value does not meet the specified
          // length, an error message will be generated.
          //
          // ```proto
          // message MyString {
          //   // value length must be 5 characters
          //   string value = 1 [(buf.validate.field).string.len = 5];
          // }
          // ```
          optional uint64 len = 19 [(predefined).cel = {
            id: "string.len"
            expression: "uint(this.size()) != rules.len ? 'value length must be %s characters'.format([rules.len]) : ''"
          }];

          // `min_len` specifies that the field value must have at least the specified
          // number of characters (Unicode code points), which may differ from the number
          // of bytes in the string. If the field value contains fewer characters, an error
          // message will be generated.
          //
          // ```proto
          // message MyString {
          //   // value length must be at least 3 characters
          //   string value = 1 [(buf.validate.field).string.min_len = 3];
          // }
          // ```
          optional uint64 min_len = 2 [(predefined).cel = {
            id: "string.min_len"
            expression: "uint(this.size()) < rules.min_len ? 'value length must be at least %s characters'.format([rules.min_len]) : ''"
          }];

          // `max_len` specifies that the field value must have no more than the specified
          // number of characters (Unicode code points), which may differ from the
          // number of bytes in the string. If the field value contains more characters,
          // an error message will be generated.
          //
          // ```proto
          // message MyString {
          //   // value length must be at most 10 characters
          //   string value = 1 [(buf.validate.field).string.max_len = 10];
          // }
          // ```
          optional uint64 max_len = 3 [(predefined).cel = {
            id: "string.max_len"
            expression: "uint(this.size()) > rules.max_len ? 'value length must be at most %s characters'.format([rules.max_len]) : ''"
          }];

          // `len_bytes` dictates that the field value must have the specified number of
          // bytes. If the field value does not match the specified length in bytes,
          // an error message will be generated.
          //
          // ```proto
          // message MyString {
          //   // value length must be 6 bytes
          //   string value = 1 [(buf.validate.field).string.len_bytes = 6];
          // }
          // ```
          optional uint64 len_bytes = 20 [(predefined).cel = {
            id: "string.len_bytes"
            expression: "uint(bytes(this).size()) != rules.len_bytes ? 'value length must be %s bytes'.format([rules.len_bytes]) : ''"
          }];

          // `min_bytes` specifies that the field value must have at least the specified
          // number of bytes. If the field value contains fewer bytes, an error message
          // will be generated.
          //
          // ```proto
          // message MyString {
          //   // value length must be at least 4 bytes
          //   string value = 1 [(buf.validate.field).string.min_bytes = 4];
          // }
          //
          // ```
          optional uint64 min_bytes = 4 [(predefined).cel = {
            id: "string.min_bytes"
            expression: "uint(bytes(this).size()) < rules.min_bytes ? 'value length must be at least %s bytes'.format([rules.min_bytes]) : ''"
          }];

          // `max_bytes` specifies that the field value must have no more than the
          //specified number of bytes. If the field value contains more bytes, an
          // error message will be generated.
          //
          // ```proto
          // message MyString {
          //   // value length must be at most 8 bytes
          //   string value = 1 [(buf.validate.field).string.max_bytes = 8];
          // }
          // ```
          optional uint64 max_bytes = 5 [(predefined).cel = {
            id: "string.max_bytes"
            expression: "uint(bytes(this).size()) > rules.max_bytes ? 'value length must be at most %s bytes'.format([rules.max_bytes]) : ''"
          }];

          // `pattern` specifies that the field value must match the specified
          // regular expression (RE2 syntax), with the expression provided without any
          // delimiters. If the field value doesn't match the regular expression, an
          // error message will be generated.
          //
          // ```proto
          // message MyString {
          //   // value does not match regex pattern `^[a-zA-Z]//$`
          //   string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
          // }
          // ```
          optional string pattern = 6 [(predefined).cel = {
            id: "string.pattern"
            expression: "!this.matches(rules.pattern) ? 'value does not match regex pattern `%s`'.format([rules.pattern]) : ''"
          }];

          // `prefix` specifies that the field value must have the
          //specified substring at the beginning of the string. If the field value
          // doesn't start with the specified prefix, an error message will be
          // generated.
          //
          // ```proto
          // message MyString {
          //   // value does not have prefix `pre`
          //   string value = 1 [(buf.validate.field).string.prefix = "pre"];
          // }
          // ```
          optional string prefix = 7 [(predefined).cel = {
            id: "string.prefix"
            expression: "!this.startsWith(rules.prefix) ? 'value does not have prefix `%s`'.format([rules.prefix]) : ''"
          }];

          // `suffix` specifies that the field value must have the
          //specified substring at the end of the string. If the field value doesn't
          // end with the specified suffix, an error message will be generated.
          //
          // ```proto
          // message MyString {
          //   // value does not have suffix `post`
          //   string value = 1 [(buf.validate.field).string.suffix = "post"];
          // }
          // ```
          optional string suffix = 8 [(predefined).cel = {
            id: "string.suffix"
            expression: "!this.endsWith(rules.suffix) ? 'value does not have suffix `%s`'.format([rules.suffix]) : ''"
          }];

          // `contains` specifies that the field value must have the
          //specified substring anywhere in the string. If the field value doesn't
          // contain the specified substring, an error message will be generated.
          //
          // ```proto
          // message MyString {
          //   // value does not contain substring `inside`.
          //   string value = 1 [(buf.validate.field).string.contains = "inside"];
          // }
          // ```
          optional string contains = 9 [(predefined).cel = {
            id: "string.contains"
            expression: "!this.contains(rules.contains) ? 'value does not contain substring `%s`'.format([rules.contains]) : ''"
          }];

          // `not_contains` specifies that the field value must not have the
          //specified substring anywhere in the string. If the field value contains
          // the specified substring, an error message will be generated.
          //
          // ```proto
          // message MyString {
          //   // value contains substring `inside`.
          //   string value = 1 [(buf.validate.field).string.not_contains = "inside"];
          // }
          // ```
          optional string not_contains = 23 [(predefined).cel = {
            id: "string.not_contains"
            expression: "this.contains(rules.not_contains) ? 'value contains substring `%s`'.format([rules.not_contains]) : ''"
          }];

          // `in` specifies that the field value must be equal to one of the specified
          // values. If the field value isn't one of the specified values, an error
          // message will be generated.
          //
          // ```proto
          // message MyString {
          //   // value must be in list ["apple", "banana"]
          //   repeated string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
          // }
          // ```
          repeated string in = 10 [(predefined).cel = {
            id: "string.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` specifies that the field value cannot be equal to any
          // of the specified values. If the field value is one of the specified values,
          // an error message will be generated.
          // ```proto
          // message MyString {
          //   // value must not be in list ["orange", "grape"]
          //   repeated string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
          // }
          // ```
          repeated string not_in = 11 [(predefined).cel = {
            id: "string.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `WellKnown` rules provide advanced constraints against common string
          // patterns
          oneof well_known {
            // `email` specifies that the field value must be a valid email address
            // (addr-spec only) as defined by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1).
            // If the field value isn't a valid email address, an error message will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid email address
            //   string value = 1 [(buf.validate.field).string.email = true];
            // }
            // ```
            bool email = 12 [
              (predefined).cel = {
                id: "string.email"
                message: "value must be a valid email address"
                expression: "!rules.email || this == '' || this.isEmail()"
              },
              (predefined).cel = {
                id: "string.email_empty"
                message: "value is empty, which is not a valid email address"
                expression: "!rules.email || this != ''"
              }
            ];

            // `hostname` specifies that the field value must be a valid
            // hostname as defined by [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034#section-3.5). This constraint doesn't support
            // internationalized domain names (IDNs). If the field value isn't a
            // valid hostname, an error message will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid hostname
            //   string value = 1 [(buf.validate.field).string.hostname = true];
            // }
            // ```
            bool hostname = 13 [
              (predefined).cel = {
                id: "string.hostname"
                message: "value must be a valid hostname"
                expression: "!rules.hostname || this == '' || this.isHostname()"
              },
              (predefined).cel = {
                id: "string.hostname_empty"
                message: "value is empty, which is not a valid hostname"
                expression: "!rules.hostname || this != ''"
              }
            ];

            // `ip` specifies that the field value must be a valid IP
            // (v4 or v6) address, without surrounding square brackets for IPv6 addresses.
            // If the field value isn't a valid IP address, an error message will be
            // generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid IP address
            //   string value = 1 [(buf.validate.field).string.ip = true];
            // }
            // ```
            bool ip = 14 [
              (predefined).cel = {
                id: "string.ip"
                message: "value must be a valid IP address"
                expression: "!rules.ip || this == '' || this.isIp()"
              },
              (predefined).cel = {
                id: "string.ip_empty"
                message: "value is empty, which is not a valid IP address"
                expression: "!rules.ip || this != ''"
              }
            ];

            // `ipv4` specifies that the field value must be a valid IPv4
            // address. If the field value isn't a valid IPv4 address, an error message
            // will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid IPv4 address
            //   string value = 1 [(buf.validate.field).string.ipv4 = true];
            // }
            // ```
            bool ipv4 = 15 [
              (predefined).cel = {
                id: "string.ipv4"
                message: "value must be a valid IPv4 address"
                expression: "!rules.ipv4 || this == '' || this.isIp(4)"
              },
              (predefined).cel = {
                id: "string.ipv4_empty"
                message: "value is empty, which is not a valid IPv4 address"
                expression: "!rules.ipv4 || this != ''"
              }
            ];

            // `ipv6` specifies that the field value must be a valid
            // IPv6 address, without surrounding square brackets. If the field value is
            // not a valid IPv6 address, an error message will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid IPv6 address
            //   string value = 1 [(buf.validate.field).string.ipv6 = true];
            // }
            // ```
            bool ipv6 = 16 [
              (predefined).cel = {
                id: "string.ipv6"
                message: "value must be a valid IPv6 address"
                expression: "!rules.ipv6 || this == '' || this.isIp(6)"
              },
              (predefined).cel = {
                id: "string.ipv6_empty"
                message: "value is empty, which is not a valid IPv6 address"
                expression: "!rules.ipv6 || this != ''"
              }
            ];

            // `uri` specifies that the field value must be a valid URI as defined by
            // [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986#section-3).
            //
            // If the field value isn't a valid URI, an error message will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid URI
            //   string value = 1 [(buf.validate.field).string.uri = true];
            // }
            // ```
            bool uri = 17 [
              (predefined).cel = {
                id: "string.uri"
                message: "value must be a valid URI"
                expression: "!rules.uri || this == '' || this.isUri()"
              },
              (predefined).cel = {
                id: "string.uri_empty"
                message: "value is empty, which is not a valid URI"
                expression: "!rules.uri || this != ''"
              }
            ];

            // `uri_ref` specifies that the field value must be a valid URI Reference as
            // defined by [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986#section-4.1).
            //
            // A URI Reference is either a [URI](https://datatracker.ietf.org/doc/html/rfc3986#section-3),
            // or a [Relative Reference](https://datatracker.ietf.org/doc/html/rfc3986#section-4.2).
            //
            // If the field value isn't a valid URI Reference, an error message will be
            // generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid URI Reference
            //   string value = 1 [(buf.validate.field).string.uri_ref = true];
            // }
            // ```
            bool uri_ref = 18 [(predefined).cel = {
              id: "string.uri_ref"
              message: "value must be a valid URI Reference"
              expression: "!rules.uri_ref || this.isUriRef()"
            }];

            // `address` specifies that the field value must be either a valid hostname
            // as defined by [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034#section-3.5)
            // (which doesn't support internationalized domain names or IDNs) or a valid
            // IP (v4 or v6). If the field value isn't a valid hostname or IP, an error
            // message will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid hostname, or ip address
            //   string value = 1 [(buf.validate.field).string.address = true];
            // }
            // ```
            bool address = 21 [
              (predefined).cel = {
                id: "string.address"
                message: "value must be a valid hostname, or ip address"
                expression: "!rules.address || this == '' || this.isHostname() || this.isIp()"
              },
              (predefined).cel = {
                id: "string.address_empty"
                message: "value is empty, which is not a valid hostname, or ip address"
                expression: "!rules.address || this != ''"
              }
            ];

            // `uuid` specifies that the field value must be a valid UUID as defined by
            // [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2). If the
            // field value isn't a valid UUID, an error message will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid UUID
            //   string value = 1 [(buf.validate.field).string.uuid = true];
            // }
            // ```
            bool uuid = 22 [
              (predefined).cel = {
                id: "string.uuid"
                message: "value must be a valid UUID"
                expression: "!rules.uuid || this == '' || this.matches('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')"
              },
              (predefined).cel = {
                id: "string.uuid_empty"
                message: "value is empty, which is not a valid UUID"
                expression: "!rules.uuid || this != ''"
              }
            ];

            // `tuuid` (trimmed UUID) specifies that the field value must be a valid UUID as
            // defined by [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2) with all dashes
            // omitted. If the field value isn't a valid UUID without dashes, an error message
            // will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid trimmed UUID
            //   string value = 1 [(buf.validate.field).string.tuuid = true];
            // }
            // ```
            bool tuuid = 33 [
              (predefined).cel = {
                id: "string.tuuid"
                message: "value must be a valid trimmed UUID"
                expression: "!rules.tuuid || this == '' || this.matches('^[0-9a-fA-F]{32}$')"
              },
              (predefined).cel = {
                id: "string.tuuid_empty"
                message: "value is empty, which is not a valid trimmed UUID"
                expression: "!rules.tuuid || this != ''"
              }
            ];

            // `ip_with_prefixlen` specifies that the field value must be a valid IP (v4 or v6)
            // address with prefix length. If the field value isn't a valid IP with prefix
            // length, an error message will be generated.
            //
            //
            // ```proto
            // message MyString {
            //   // value must be a valid IP with prefix length
            //    string value = 1 [(buf.validate.field).string.ip_with_prefixlen = true];
            // }
            // ```
            bool ip_with_prefixlen = 26 [
              (predefined).cel = {
                id: "string.ip_with_prefixlen"
                message: "value must be a valid IP prefix"
                expression: "!rules.ip_with_prefixlen || this == '' || this.isIpPrefix()"
              },
              (predefined).cel = {
                id: "string.ip_with_prefixlen_empty"
                message: "value is empty, which is not a valid IP prefix"
                expression: "!rules.ip_with_prefixlen || this != ''"
              }
            ];

            // `ipv4_with_prefixlen` specifies that the field value must be a valid
            // IPv4 address with prefix.
            // If the field value isn't a valid IPv4 address with prefix length,
            // an error message will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid IPv4 address with prefix length
            //    string value = 1 [(buf.validate.field).string.ipv4_with_prefixlen = true];
            // }
            // ```
            bool ipv4_with_prefixlen = 27 [
              (predefined).cel = {
                id: "string.ipv4_with_prefixlen"
                message: "value must be a valid IPv4 address with prefix length"
                expression: "!rules.ipv4_with_prefixlen || this == '' || this.isIpPrefix(4)"
              },
              (predefined).cel = {
                id: "string.ipv4_with_prefixlen_empty"
                message: "value is empty, which is not a valid IPv4 address with prefix length"
                expression: "!rules.ipv4_with_prefixlen || this != ''"
              }
            ];

            // `ipv6_with_prefixlen` specifies that the field value must be a valid
            // IPv6 address with prefix length.
            // If the field value is not a valid IPv6 address with prefix length,
            // an error message will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid IPv6 address prefix length
            //    string value = 1 [(buf.validate.field).string.ipv6_with_prefixlen = true];
            // }
            // ```
            bool ipv6_with_prefixlen = 28 [
              (predefined).cel = {
                id: "string.ipv6_with_prefixlen"
                message: "value must be a valid IPv6 address with prefix length"
                expression: "!rules.ipv6_with_prefixlen || this == '' || this.isIpPrefix(6)"
              },
              (predefined).cel = {
                id: "string.ipv6_with_prefixlen_empty"
                message: "value is empty, which is not a valid IPv6 address with prefix length"
                expression: "!rules.ipv6_with_prefixlen || this != ''"
              }
            ];

            // `ip_prefix` specifies that the field value must be a valid IP (v4 or v6) prefix.
            // If the field value isn't a valid IP prefix, an error message will be
            // generated. The prefix must have all zeros for the masked bits of the prefix (e.g.,
            // `127.0.0.0/16`, not `127.0.0.1/16`).
            //
            // ```proto
            // message MyString {
            //   // value must be a valid IP prefix
            //    string value = 1 [(buf.validate.field).string.ip_prefix = true];
            // }
            // ```
            bool ip_prefix = 29 [
              (predefined).cel = {
                id: "string.ip_prefix"
                message: "value must be a valid IP prefix"
                expression: "!rules.ip_prefix || this == '' || this.isIpPrefix(true)"
              },
              (predefined).cel = {
                id: "string.ip_prefix_empty"
                message: "value is empty, which is not a valid IP prefix"
                expression: "!rules.ip_prefix || this != ''"
              }
            ];

            // `ipv4_prefix` specifies that the field value must be a valid IPv4
            // prefix. If the field value isn't a valid IPv4 prefix, an error message
            // will be generated. The prefix must have all zeros for the masked bits of
            // the prefix (e.g., `127.0.0.0/16`, not `127.0.0.1/16`).
            //
            // ```proto
            // message MyString {
            //   // value must be a valid IPv4 prefix
            //    string value = 1 [(buf.validate.field).string.ipv4_prefix = true];
            // }
            // ```
            bool ipv4_prefix = 30 [
              (predefined).cel = {
                id: "string.ipv4_prefix"
                message: "value must be a valid IPv4 prefix"
                expression: "!rules.ipv4_prefix || this == '' || this.isIpPrefix(4, true)"
              },
              (predefined).cel = {
                id: "string.ipv4_prefix_empty"
                message: "value is empty, which is not a valid IPv4 prefix"
                expression: "!rules.ipv4_prefix || this != ''"
              }
            ];

            // `ipv6_prefix` specifies that the field value must be a valid IPv6 prefix.
            // If the field value is not a valid IPv6 prefix, an error message will be
            // generated. The prefix must have all zeros for the masked bits of the prefix
            // (e.g., `2001:db8::/48`, not `2001:db8::1/48`).
            //
            // ```proto
            // message MyString {
            //   // value must be a valid IPv6 prefix
            //    string value = 1 [(buf.validate.field).string.ipv6_prefix = true];
            // }
            // ```
            bool ipv6_prefix = 31 [
              (predefined).cel = {
                id: "string.ipv6_prefix"
                message: "value must be a valid IPv6 prefix"
                expression: "!rules.ipv6_prefix || this == '' || this.isIpPrefix(6, true)"
              },
              (predefined).cel = {
                id: "string.ipv6_prefix_empty"
                message: "value is empty, which is not a valid IPv6 prefix"
                expression: "!rules.ipv6_prefix || this != ''"
              }
            ];

            // `host_and_port` specifies the field value must be a valid host and port
            // pair. The host must be a valid hostname or IP address while the port
            // must be in the range of 0-65535, inclusive. IPv6 addresses must be delimited
            // with square brackets (e.g., `[::1]:1234`).
            bool host_and_port = 32 [
              (predefined).cel = {
                id: "string.host_and_port"
                message: "value must be a valid host (hostname or IP address) and port pair"
                expression: "!rules.host_and_port || this == '' || this.isHostAndPort(true)"
              },
              (predefined).cel = {
                id: "string.host_and_port_empty"
                message: "value is empty, which is not a valid host and port pair"
                expression: "!rules.host_and_port || this != ''"
              }
            ];

            // `well_known_regex` specifies a common well-known pattern
            // defined as a regex. If the field value doesn't match the well-known
            // regex, an error message will be generated.
            //
            // ```proto
            // message MyString {
            //   // value must be a valid HTTP header value
            //   string value = 1 [(buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_VALUE];
            // }
            // ```
            //
            // #### KnownRegex
            //
            // `well_known_regex` contains some well-known patterns.
            //
            // | Name                          | Number | Description                               |
            // |-------------------------------|--------|-------------------------------------------|
            // | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
            // | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2)  |
            // | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4) |
            KnownRegex well_known_regex = 24 [
              (predefined).cel = {
                id: "string.well_known_regex.header_name"
                message: "value must be a valid HTTP header name"
                expression:
                  "rules.well_known_regex != 1 || this == '' || this.matches(!has(rules.strict) || rules.strict ?"
                  "'^:?[0-9a-zA-Z!#$%&\\'*+-.^_|~\\x60]+$' :"
                  "'^[^\\u0000\\u000A\\u000D]+$')"
              },
              (predefined).cel = {
                id: "string.well_known_regex.header_name_empty"
                message: "value is empty, which is not a valid HTTP header name"
                expression: "rules.well_known_regex != 1 || this != ''"
              },
              (predefined).cel = {
                id: "string.well_known_regex.header_value"
                message: "value must be a valid HTTP header value"
                expression:
                  "rules.well_known_regex != 2 || this.matches(!has(rules.strict) || rules.strict ?"
                  "'^[^\\u0000-\\u0008\\u000A-\\u001F\\u007F]*$' :"
                  "'^[^\\u0000\\u000A\\u000D]*$')"
              }
            ];
          }

          // This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
          // enable strict header validation. By default, this is true, and HTTP header
          // validations are [RFC-compliant](https://datatracker.ietf.org/doc/html/rfc7230#section-3). Setting to false will enable looser
          // validations that only disallow `\r\n\0` characters, which can be used to
          // bypass header matching rules.
          //
          // ```proto
          // message MyString {
          //   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
          //   string value = 1 [(buf.validate.field).string.strict = false];
          // }
          // ```
          optional bool strict = 25;

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyString {
          //   string value = 1 [
          //     (buf.validate.field).string.example = "hello",
          //     (buf.validate.field).string.example = "world"
          //   ];
          // }
          // ```
          repeated string example = 34 [(predefined).cel = {
            id: "string.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // WellKnownRegex contain some well-known patterns.
        enum KnownRegex {
          KNOWN_REGEX_UNSPECIFIED = 0;

          // HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2).
          KNOWN_REGEX_HTTP_HEADER_NAME = 1;

          // HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4).
          KNOWN_REGEX_HTTP_HEADER_VALUE = 2;
        }

        // BytesRules describe the constraints applied to `bytes` values. These rules
        // may also be applied to the `google.protobuf.BytesValue` Well-Known-Type.
        message BytesRules {
          // `const` requires the field value to exactly match the specified bytes
          // value. If the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyBytes {
          //   // value must be "\x01\x02\x03\x04"
          //   bytes value = 1 [(buf.validate.field).bytes.const = "\x01\x02\x03\x04"];
          // }
          // ```
          optional bytes const = 1 [(predefined).cel = {
            id: "bytes.const"
            expression: "this != rules.const ? 'value must be %x'.format([rules.const]) : ''"
          }];

          // `len` requires the field value to have the specified length in bytes.
          // If the field value doesn't match, an error message is generated.
          //
          // ```proto
          // message MyBytes {
          //   // value length must be 4 bytes.
          //   optional bytes value = 1 [(buf.validate.field).bytes.len = 4];
          // }
          // ```
          optional uint64 len = 13 [(predefined).cel = {
            id: "bytes.len"
            expression: "uint(this.size()) != rules.len ? 'value length must be %s bytes'.format([rules.len]) : ''"
          }];

          // `min_len` requires the field value to have at least the specified minimum
          // length in bytes.
          // If the field value doesn't meet the requirement, an error message is generated.
          //
          // ```proto
          // message MyBytes {
          //   // value length must be at least 2 bytes.
          //   optional bytes value = 1 [(buf.validate.field).bytes.min_len = 2];
          // }
          // ```
          optional uint64 min_len = 2 [(predefined).cel = {
            id: "bytes.min_len"
            expression: "uint(this.size()) < rules.min_len ? 'value length must be at least %s bytes'.format([rules.min_len]) : ''"
          }];

          // `max_len` requires the field value to have at most the specified maximum
          // length in bytes.
          // If the field value exceeds the requirement, an error message is generated.
          //
          // ```proto
          // message MyBytes {
          //   // value must be at most 6 bytes.
          //   optional bytes value = 1 [(buf.validate.field).bytes.max_len = 6];
          // }
          // ```
          optional uint64 max_len = 3 [(predefined).cel = {
            id: "bytes.max_len"
            expression: "uint(this.size()) > rules.max_len ? 'value must be at most %s bytes'.format([rules.max_len]) : ''"
          }];

          // `pattern` requires the field value to match the specified regular
          // expression ([RE2 syntax](https://github.com/google/re2/wiki/Syntax)).
          // The value of the field must be valid UTF-8 or validation will fail with a
          // runtime error.
          // If the field value doesn't match the pattern, an error message is generated.
          //
          // ```proto
          // message MyBytes {
          //   // value must match regex pattern "^[a-zA-Z0-9]+$".
          //   optional bytes value = 1 [(buf.validate.field).bytes.pattern = "^[a-zA-Z0-9]+$"];
          // }
          // ```
          optional string pattern = 4 [(predefined).cel = {
            id: "bytes.pattern"
            expression: "!string(this).matches(rules.pattern) ? 'value must match regex pattern `%s`'.format([rules.pattern]) : ''"
          }];

          // `prefix` requires the field value to have the specified bytes at the
          // beginning of the string.
          // If the field value doesn't meet the requirement, an error message is generated.
          //
          // ```proto
          // message MyBytes {
          //   // value does not have prefix \x01\x02
          //   optional bytes value = 1 [(buf.validate.field).bytes.prefix = "\x01\x02"];
          // }
          // ```
          optional bytes prefix = 5 [(predefined).cel = {
            id: "bytes.prefix"
            expression: "!this.startsWith(rules.prefix) ? 'value does not have prefix %x'.format([rules.prefix]) : ''"
          }];

          // `suffix` requires the field value to have the specified bytes at the end
          // of the string.
          // If the field value doesn't meet the requirement, an error message is generated.
          //
          // ```proto
          // message MyBytes {
          //   // value does not have suffix \x03\x04
          //   optional bytes value = 1 [(buf.validate.field).bytes.suffix = "\x03\x04"];
          // }
          // ```
          optional bytes suffix = 6 [(predefined).cel = {
            id: "bytes.suffix"
            expression: "!this.endsWith(rules.suffix) ? 'value does not have suffix %x'.format([rules.suffix]) : ''"
          }];

          // `contains` requires the field value to have the specified bytes anywhere in
          // the string.
          // If the field value doesn't meet the requirement, an error message is generated.
          //
          // ```protobuf
          // message MyBytes {
          //   // value does not contain \x02\x03
          //   optional bytes value = 1 [(buf.validate.field).bytes.contains = "\x02\x03"];
          // }
          // ```
          optional bytes contains = 7 [(predefined).cel = {
            id: "bytes.contains"
            expression: "!this.contains(rules.contains) ? 'value does not contain %x'.format([rules.contains]) : ''"
          }];

          // `in` requires the field value to be equal to one of the specified
          // values. If the field value doesn't match any of the specified values, an
          // error message is generated.
          //
          // ```protobuf
          // message MyBytes {
          //   // value must in ["\x01\x02", "\x02\x03", "\x03\x04"]
          //   optional bytes value = 1 [(buf.validate.field).bytes.in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
          // }
          // ```
          repeated bytes in = 8 [(predefined).cel = {
            id: "bytes.in"
            expression: "dyn(rules)['in'].size() > 0 && !(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to be not equal to any of the specified
          // values.
          // If the field value matches any of the specified values, an error message is
          // generated.
          //
          // ```proto
          // message MyBytes {
          //   // value must not in ["\x01\x02", "\x02\x03", "\x03\x04"]
          //   optional bytes value = 1 [(buf.validate.field).bytes.not_in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
          // }
          // ```
          repeated bytes not_in = 9 [(predefined).cel = {
            id: "bytes.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // WellKnown rules provide advanced constraints against common byte
          // patterns
          oneof well_known {
            // `ip` ensures that the field `value` is a valid IP address (v4 or v6) in byte format.
            // If the field value doesn't meet this constraint, an error message is generated.
            //
            // ```proto
            // message MyBytes {
            //   // value must be a valid IP address
            //   optional bytes value = 1 [(buf.validate.field).bytes.ip = true];
            // }
            // ```
            bool ip = 10 [
              (predefined).cel = {
                id: "bytes.ip"
                message: "value must be a valid IP address"
                expression: "!rules.ip || this.size() == 0 || this.size() == 4 || this.size() == 16"
              },
              (predefined).cel = {
                id: "bytes.ip_empty"
                message: "value is empty, which is not a valid IP address"
                expression: "!rules.ip || this.size() != 0"
              }
            ];

            // `ipv4` ensures that the field `value` is a valid IPv4 address in byte format.
            // If the field value doesn't meet this constraint, an error message is generated.
            //
            // ```proto
            // message MyBytes {
            //   // value must be a valid IPv4 address
            //   optional bytes value = 1 [(buf.validate.field).bytes.ipv4 = true];
            // }
            // ```
            bool ipv4 = 11 [
              (predefined).cel = {
                id: "bytes.ipv4"
                message: "value must be a valid IPv4 address"
                expression: "!rules.ipv4 || this.size() == 0 || this.size() == 4"
              },
              (predefined).cel = {
                id: "bytes.ipv4_empty"
                message: "value is empty, which is not a valid IPv4 address"
                expression: "!rules.ipv4 || this.size() != 0"
              }
            ];

            // `ipv6` ensures that the field `value` is a valid IPv6 address in byte format.
            // If the field value doesn't meet this constraint, an error message is generated.
            // ```proto
            // message MyBytes {
            //   // value must be a valid IPv6 address
            //   optional bytes value = 1 [(buf.validate.field).bytes.ipv6 = true];
            // }
            // ```
            bool ipv6 = 12 [
              (predefined).cel = {
                id: "bytes.ipv6"
                message: "value must be a valid IPv6 address"
                expression: "!rules.ipv6 || this.size() == 0 || this.size() == 16"
              },
              (predefined).cel = {
                id: "bytes.ipv6_empty"
                message: "value is empty, which is not a valid IPv6 address"
                expression: "!rules.ipv6 || this.size() != 0"
              }
            ];
          }

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // message MyBytes {
          //   bytes value = 1 [
          //     (buf.validate.field).bytes.example = "\x01\x02",
          //     (buf.validate.field).bytes.example = "\x02\x03"
          //   ];
          // }
          // ```
          repeated bytes example = 14 [(predefined).cel = {
            id: "bytes.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // EnumRules describe the constraints applied to `enum` values.
        message EnumRules {
          // `const` requires the field value to exactly match the specified enum value.
          // If the field value doesn't match, an error message is generated.
          //
          // ```proto
          // enum MyEnum {
          //   MY_ENUM_UNSPECIFIED = 0;
          //   MY_ENUM_VALUE1 = 1;
          //   MY_ENUM_VALUE2 = 2;
          // }
          //
          // message MyMessage {
          //   // The field `value` must be exactly MY_ENUM_VALUE1.
          //   MyEnum value = 1 [(buf.validate.field).enum.const = 1];
          // }
          // ```
          optional int32 const = 1 [(predefined).cel = {
            id: "enum.const"
            expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''"
          }];

          // `defined_only` requires the field value to be one of the defined values for
          // this enum, failing on any undefined value.
          //
          // ```proto
          // enum MyEnum {
          //   MY_ENUM_UNSPECIFIED = 0;
          //   MY_ENUM_VALUE1 = 1;
          //   MY_ENUM_VALUE2 = 2;
          // }
          //
          // message MyMessage {
          //   // The field `value` must be a defined value of MyEnum.
          //   MyEnum value = 1 [(buf.validate.field).enum.defined_only = true];
          // }
          // ```
          optional bool defined_only = 2;

          // `in` requires the field value to be equal to one of the
          //specified enum values. If the field value doesn't match any of the
          //specified values, an error message is generated.
          //
          // ```proto
          // enum MyEnum {
          //   MY_ENUM_UNSPECIFIED = 0;
          //   MY_ENUM_VALUE1 = 1;
          //   MY_ENUM_VALUE2 = 2;
          // }
          //
          // message MyMessage {
          //   // The field `value` must be equal to one of the specified values.
          //   MyEnum value = 1 [(buf.validate.field).enum = { in: [1, 2]}];
          // }
          // ```
          repeated int32 in = 3 [(predefined).cel = {
            id: "enum.in"
            expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''"
          }];

          // `not_in` requires the field value to be not equal to any of the
          //specified enum values. If the field value matches one of the specified
          // values, an error message is generated.
          //
          // ```proto
          // enum MyEnum {
          //   MY_ENUM_UNSPECIFIED = 0;
          //   MY_ENUM_VALUE1 = 1;
          //   MY_ENUM_VALUE2 = 2;
          // }
          //
          // message MyMessage {
          //   // The field `value` must not be equal to any of the specified values.
          //   MyEnum value = 1 [(buf.validate.field).enum = { not_in: [1, 2]}];
          // }
          // ```
          repeated int32 not_in = 4 [(predefined).cel = {
            id: "enum.not_in"
            expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
          }];

          // `example` specifies values that the field may have. These values SHOULD
          // conform to other constraints. `example` values will not impact validation
          // but may be used as helpful guidance on how to populate the given field.
          //
          // ```proto
          // enum MyEnum {
          //   MY_ENUM_UNSPECIFIED = 0;
          //   MY_ENUM_VALUE1 = 1;
          //   MY_ENUM_VALUE2 = 2;
          // }
          //
          // message MyMessage {
          //     (buf.validate.field).enum.example = 1,
          //     (buf.validate.field).enum.example = 2
          // }
          // ```
          repeated int32 example = 5 [(predefined).cel = {
            id: "enum.example"
            expression: "true"
          }];

          // Extension fields in this range that have the (buf.validate.predefined)
          // option set will be treated as predefined field constraints that can then be
          // set on the field options of other fields to apply field constraints.
          // Extension numbers 1000 to 99999 are reserved for extension numbers that are
          // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
          // above this range are reserved for extension numbers that are not explicitly
          // assigned. For rules defined in publicly-consumed schemas, use of extensions
          // above 99999 is discouraged due to the risk of conflicts.
          //
          // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
          extensions 1000 to max;
        }

        // RepeatedRules describe the constraints applied to `repeated` values.
        message RepeatedRules {
          // `min_items` requires that this field must contain at least the specified
          // minimum number of items.
          //
          // Note that `min_items = 1` is equivalent to setting a field as `required`.
          //
          // ```proto
          // message MyRepeated {
          //   // value must contain at least  2 items
          //   repeated string value = 1 [(buf.validate.field).repeated.min_items = 2];
          // }
          // ```
          optional uint64 min_items = 1 [(predefined).cel = {
            id: "repeated.min_items"
            expression: "uint(this.size()) < rules.min_items ? 'value must contain at least %d item(s)'.format([rules.min_items]) : ''"
          }];

          // `max_items` denotes that this field must not exceed a
          // certain number of items as the upper limit. If the field contains more
          // items than specified, an error message will be generated, requiring the
          // field to maintain no more than the specified number of items.
          //
          // ```proto
          // message MyRepeated {
          //   // value must contain no more than 3 item(s)
          //   repeated string value = 1 [(buf.validate.field).repeated.max_items = 3];
          // }
          // ```
          optional uint64 max_items = 2 [(predefined).cel = {
            id: "repeated.max_items"
            expression: "uint(this.size()) > rules.max_items ? 'value must contain no more than %s item(s)'.format([rules.max_items]) : ''"
          }];

          // `unique` indicates that all elements in this field must
          // be unique. This constraint is strictly applicable to scalar and enum
          // types, with message types not being supported.
          //
          // ```proto
          // message MyRepeated {
          //   // repeated value must contain unique items
          //   repeated string value = 1 [(buf.validate.field).repeated.unique = true];
          // }
          // ```
          optional bool unique = 3 [(predefined).cel = {
            id: "repeated.unique"
            message: "repeated value must contain unique items"
            expression: "!rules.unique || this.unique()"
          }];
        }
        
        message RootMsg {
          optional FloatRules floatRules = 1;
          optional DoubleRules doubleRules = 2;
          optional Int32Rules int32Rules = 3;
          optional Int64Rules int64Rules = 4;
          optional UInt32Rules uInt32Rules = 5;
          optional UInt64Rules uInt64Rules = 6;
          optional SInt32Rules sInt32Rules = 7;
          optional SInt64Rules sInt64Rules = 8;
          optional Fixed32Rules fixed32Rules = 9;
          optional Fixed64Rules fixed64Rules = 10;
          optional SFixed32Rules sFixed32Rules = 11;
          optional SFixed64Rules sFixed64Rules = 12;
          optional BoolRules boolRules = 13;
          optional StringRules stringRules = 14;
          optional BytesRules bytesRules = 15;
          optional EnumRules enumRules = 16;
          optional RepeatedRules repeatedRules = 17;
        }
